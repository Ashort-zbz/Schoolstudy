# Java编程思想——Bruce Eckel

源代码，资料下载：https://www.mindviewllc.com

[TOC]

## 第一章 对象导论

编程语言的产生始于对机器的模仿。OOP（面向对象程序设计）。

### 1.1 抽象过程

所有编程语言都提供抽象机制。人类能够解决的问题的复杂性直接取决于对象的类型和质量。所谓“类型”即“所抽象的是什么？”**汇编语言**是对底层机器的轻微抽象。接着出现**“命令式”语言**（FORTRAN、BASIC、C等）都是对汇编语言的抽象。这些在汇编的基础上有大幅度改进，但其所作的主要抽象仍要求在解决问题时**要基于计算机结构**，而不是基于所要解决的问题的结构来考虑。

另一种对机器建模的方式就是只针对待解决问题建模。OOP就是其中一种，OOP通过向程序员提供表示问题空间中的元素的工具。将问题空间中的元素及其在解空间中的表示称为“对象”。OOP思想实质是：程序可通过添加新类型的对象使自身适用于某个特定问题。

Alan Kay 曾总结了第一个成功的OOP语言、同时也是Java所基于的语言之一的smalltalk的五个特性：

1. 万物皆为对象。

2. 程序是对象的集合，它们通过发送消息来告知彼此要做的。

3. 每个对象都有自己的由其他对象所构成的存储。

4. 每个对象都拥有类型。
5. 某一特定类型的所有对象都可以接受同样的信息。

Booch 对对象提出了一个更加简洁的描述：**对象具有状态、行为和标识。**这意味着每个对象都可拥有内部数据（它们给出该对象的状态）和方法（它们产生行为），并且每个对象都可以唯一地与其他对象区分开，具体说，就是每个对象在内存中都有一个唯一的地址。

### 1.2 每个对象都有一个接口

亚里士多德大概是第一个深入研究**类型（type）**的哲学家，他曾提出过鱼类和鸟类这样的概念。**所有对象都是唯一的，但同时也是具有相同特性和行为的对象所属的类的一部分。**这种思想被直接应用于第一个OOP语言Simula-67，在程序中使用关键字**class**引入新的类型。Simula，“人如其名”，是为了开发诸如经典问题“银行出纳员问题”（bank teller problem）这样的仿真程序创建的。在银行出纳员问题中，有出纳、客户、账户、货币单位等许多“对象”。在程序执行期间具有不同的状态而其他方面都相似的对象会被分组到对象的类中，即关键字**class**的由来。创建抽象数据类型（类）是OOP的基本概念之一。你可以创建某一类型的变量（按照面向对象的说法，称为**对象**或**实例**），然后操作这些变量（称其为**发送消息**或**请求**）。每个类的成员或元素都具有某种共性：每个账户都有结余金额。同时，每个成员都有自身的状态：每个账户都有不同的结余金额。因此，出纳、客户、账户、货币单位都可以在程序中被表示成唯一的实体。这些实体就是对象，每个对象都属于定义了特性和行为的某个特定的类。

事实上所有OOP语言都使用class关键词来表示数据类型。**当看到类型这一词是，可将其作为类来考虑，反之亦然**。因为类描述了具有相同特性（数据元素）和行为（功能）的对象集合，所以一个类实际上就是一个数据类型。程序员可以通过定义类来适应问题，而不再被迫只能使用现有的用来表示机器中的存储单元的数据类型。可以通过需求，通过添加新的数据类型来扩展编程语言。

OOP方法并不是仅限于构建仿真程序，任何程序是所设计的系统的一种仿真，OOP技术的应用确实可以将大量的问题很容易的降解为一个简单的解决方案。一旦类被建立，就可以随心所欲地创建类的任意个对象，然后操作它们，就像是它们是存在于待求解问题中的元素一样。事实上，OOP的挑战之一，就是**在问题空间的元素和解空间的对象之间创建一对一的映射**。

如何获得有用的对象？必须有某种方式产生对对象的请求，使对象完成各种任务。每个对象都只能满足某些请求，这些请求由对象的**接口（interface）**所定义，决定接口的便是类型。接口确定了对某一特定对象所能发出的**请求**。但是，在程序中必须有满足这些请求的代码，这些代码与隐藏的数据一起构成了**实现**。此过程可概括为：向某个对象“发送消息”（产生请求），这个对象便知道此消息的目的，然后执行对应的程序代码。

### 1.3 每个对象都提供服务

当正在试图开发或理解一个程序设计时，最好的方法就是**将对象想象为“服务提供者”**。程序本身向用户提供服务，它通过其他对象提供的服务来实现这一目的。程序员的目标就是去创建（活着最好是在现有代码库中寻找）能够提供理想的服务来解决问题的一系列对象。

开始做这件事的一种方式就是问自己：“如果我能将问题从表象中抽取出来，那么什么样的对象可以马上解决问题？”对于那些不存在的对象，它们看上去是什么样子？它们能提供那些服务？它们需要哪些对象才能履行它们的义务？这是将问题分解为对象集合的一种合理方式。

将对象看作服务提供者还有一个附带好处：有助于提高对象的内聚性。**高内聚**是软件设计的基本质量要求之一：这意味着一个软件构建（例如一个对象，也有可能指一个语法或一个对象库）的各个方面“组合”得很好。在良好的OOP中，每个对象都可以很好地完成一项任务但是它并不试图做更多的事。

将对象作为服务提供者看待是一件伟大的简化工具，这不仅在设计中非常有用，而且当其他人试图理解你的代码或重用某个对象时，如果他们看出这个对象所能提供的服务的价值，它会使调整对象以适应其设计的过程变得简单多。

### 1.4 被隐藏的具体实现

将程序员按照角色分为**类创建者**（能创建新数据类型的程序员）和**客户端程序员**（在应用开发中使用数据类型的类消费者）是有益的，客户端程序员目标是收集各种用来实现快速应用开发的类。类创建者目标是构建类，这种类只向客户端程序员暴露必需的部分，隐藏其他部分。为什么？如果加以隐藏，那么客户端程序员将不能访问它，这意味着类创建者可以任意修改被隐藏的部分，不用担心对其他任何人造成影响。被隐藏的部分通常代表对象内部脆弱的部分，它们很容易被粗心或不知内情的客户端程序员所毁坏，因此将实现隐藏起来可以减少程序bug。

在任何相互关系中，具有关系所涉及的各方都遵守的边界是十分重要的事情。当创建一个类库时，就建立了与客户端程序员之间的关系。如果他们不受任何约束，没有任何控制访问，所有东西将赤裸裸暴露在人面前。

访问控制第一个存在原因就是让客户端程序员无法触及他们不应触及的部分。

访问控制的第二个存在原因就是允许库设计者可以改变类内部的工作方式而不用担心会影响到客户端程序员。

Java用三个关键字在类的内部设定边界：**public**、**private**、**protected**。这些**访问指定词**（access specifier）决定了紧跟其后被定义的东西可以被谁使用。**public**表示紧随其后的元素对任何人都是可用的，**private**关键字表示除类型创建者和类型内部方法之外的任何人都不能访问的元素。**private**就像类创建者和客户端程序员之间的一堵墙，如果有人试图访问**private**成员，就会在编译时得到错误信息。**protected**关键字与**provide**作用相当，差别在于继承的类可以访问**protected**成员，但不能访问**private**成员。

Java还有一种默认的访问权限，当没有使用前面提到的访问指定词时，它将发挥作用。这种权限通常被称为**包访问权限**，在这种权限下，类可以访问同一个包（库构件）中的其他类成员，但是在包之外，这些成员就如同指定了**private**一样。